import discord
from discord.ext import commands
import random
import asyncio
import json
import os
from datetime import datetime, timedelta

class Fun(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.trivia_sessions = {}
        self.quiz_data = self.load_quiz_data()
        self.user_stats = self.load_user_stats()
        
    def load_quiz_data(self):
        return [
            {"pergunta": "Qual linguagem foi criada por Guido van Rossum?", "opcoes": ["Python", "Java", "C++", "JavaScript"], "resposta": 0},
            {"pergunta": "O que significa 'HTML'?", "opcoes": ["Hyper Text Markup Language", "High Tech Modern Language", "Home Tool Markup Language", "Hyper Transfer Markup Language"], "resposta": 0},
            {"pergunta": "Qual empresa criou o sistema operacional Android?", "opcoes": ["Apple", "Microsoft", "Google", "Samsung"], "resposta": 2},
            {"pergunta": "Em que ano foi criado o Python?", "opcoes": ["1989", "1991", "1995", "2000"], "resposta": 1},
            {"pergunta": "Qual √© a linguagem mais usada para desenvolvimento web frontend?", "opcoes": ["Python", "Java", "JavaScript", "C#"], "resposta": 2}
        ]
    
    def load_user_stats(self):
        if os.path.exists('fun_stats.json'):
            with open('fun_stats.json', 'r') as f:
                return json.load(f)
        return {}
    
    def save_user_stats(self):
        with open('fun_stats.json', 'w') as f:
            json.dump(self.user_stats, f, indent=4)
    
    def update_user_stats(self, user_id, stat_type):
        user_id = str(user_id)
        if user_id not in self.user_stats:
            self.user_stats[user_id] = {"quiz_wins": 0, "games_played": 0, "trivia_points": 0}
        self.user_stats[user_id][stat_type] += 1
        self.save_user_stats()

    @commands.command(name='piada')
    async def piada(self, ctx):
        piadas = [
            "Por que o programador confunde Halloween com Natal? Porque OCT 31 == DEC 25!",
            "Qual o animal que programa? O C# (C sharp)!",
            "Por que o Java √© t√£o pregui√ßoso? Porque ele s√≥ executa m√©todos quando chamado.",
            "Por que os programadores preferem o modo escuro? Porque a luz atrai bugs!",
            "Como voc√™ chama um programador que n√£o documenta o c√≥digo? Um terrorista!",
            "Por que o CSS estava triste? Porque n√£o tinha classe!",
            "O que um programador faz quando est√° com fome? Ele come um byte!",
            "Por que o JavaScript foi ao psic√≥logo? Porque tinha problemas de closure!",
            "Como se chama um programador que trabalha no jardim? Um dev-ops!",
            "Por que o Python √© t√£o educado? Porque sempre usa indenta√ß√£o!"
        ]
        await ctx.reply(random.choice(piadas), mention_author=False)
        self.update_user_stats(ctx.author.id, "games_played")

    @commands.command(name='fato')
    async def fato(self, ctx):
        fatos = [
            "O primeiro computador eletr√¥nico foi criado em 1943.",
            "O Python foi criado por Guido van Rossum e lan√ßado em 1991.",
            "O s√≠mbolo '#' em programa√ß√£o √© chamado de 'hash' ou 'sharp'.",
            "O primeiro v√≠rus de computador foi criado em 1971 e se chamava 'Creeper'.",
            "A linguagem C foi desenvolvida por Dennis Ritchie na Bell Labs em 1972.",
            "O termo 'bug' em programa√ß√£o vem de um inseto real encontrado em um computador em 1947.",
            "O primeiro dom√≠nio da internet foi registrado em 1985: symbolics.com",
            "JavaScript foi criado em apenas 10 dias por Brendan Eich em 1995.",
            "O protocolo HTTP foi criado por Tim Berners-Lee em 1989.",
            "A linguagem Java foi originalmente chamada de 'Oak'."
        ]
        await ctx.reply(random.choice(fatos), mention_author=False)

    @commands.command(name='moeda')
    async def moeda(self, ctx):
        resultado = random.choice(['cara', 'coroa'])
        emoji = "ü™ô" if resultado == "cara" else "üîÑ"
        await ctx.reply(f"{emoji} Voc√™ jogou uma moeda e caiu: **{resultado.upper()}**!", mention_author=False)
        self.update_user_stats(ctx.author.id, "games_played")

    @commands.command(name='dados')
    async def dados(self, ctx, quantidade: int = 1, lados: int = 6):
        if quantidade > 20:
            await ctx.reply("‚ùå Voc√™ pode rolar no m√°ximo 20 dados.", mention_author=False)
            return
        if lados < 2 or lados > 100:
            await ctx.reply("‚ùå O dado deve ter entre 2 e 100 lados.", mention_author=False)
            return
            
        resultados = [random.randint(1, lados) for _ in range(quantidade)]
        total = sum(resultados)
        
        embed = discord.Embed(title="üé≤ Resultado dos Dados", color=discord.Color.blue())
        embed.add_field(name="Resultados", value=f"{', '.join(str(r) for r in resultados)}", inline=False)
        embed.add_field(name="Total", value=str(total), inline=True)
        embed.add_field(name="Dados", value=f"{quantidade}d{lados}", inline=True)
        
        await ctx.reply(embed=embed, mention_author=False)
        self.update_user_stats(ctx.author.id, "games_played")

    @commands.command(name='roleta')
    async def roleta(self, ctx, *, opcoes: str):
        opcoes_lista = [o.strip() for o in opcoes.split(',')]
        if len(opcoes_lista) < 2:
            await ctx.reply("‚ùå Forne√ßa pelo menos duas op√ß√µes separadas por v√≠rgula.", mention_author=False)
            return
        
        # Anima√ß√£o da roleta
        msg = await ctx.reply("üéØ Girando a roleta...", mention_author=False)
        await asyncio.sleep(1)
        
        for i in range(3):
            temp_escolha = random.choice(opcoes_lista)
            await msg.edit(content=f"üéØ Girando... **{temp_escolha}**")
            await asyncio.sleep(0.7)
        
        escolha_final = random.choice(opcoes_lista)
        await msg.edit(content=f"üéØ **RESULTADO:** {escolha_final}")
        
        self.update_user_stats(ctx.author.id, "games_played")

    @commands.command(name='charada')
    async def charada(self, ctx):
        charadas = [
            {"pergunta": "O que √©, o que √©? Tem pernas mas n√£o anda.", "resposta": "cadeira"},
            {"pergunta": "O que √©, o que √©? Tem dentes mas n√£o morde.", "resposta": "pente"},
            {"pergunta": "O que √©, o que √©? Passa na frente do sol e n√£o faz sombra.", "resposta": "vento"},
            {"pergunta": "O que √©, o que √©? Quanto mais se tira, maior fica.", "resposta": "buraco"},
            {"pergunta": "O que √©, o que √©? Tem coroa mas n√£o √© rei.", "resposta": "abacaxi"},
            {"pergunta": "O que √©, o que √©? Nasce grande e morre pequena.", "resposta": "vela"},
            {"pergunta": "O que √©, o que √©? Tem pesco√ßo mas n√£o tem cabe√ßa.", "resposta": "garrafa"},
            {"pergunta": "O que √©, o que √©? Quanto mais rugas tem, mais nova ela √©.", "resposta": "pneu"}
        ]
        charada = random.choice(charadas)
        
        embed = discord.Embed(title="ü§î Charada do Dia", description=charada['pergunta'], color=discord.Color.orange())
        embed.set_footer(text="Responda com !resposta <sua resposta>")
        
        await ctx.reply(embed=embed, mention_author=False)
        self.current_charada = charada

    @commands.command(name='resposta')
    async def resposta(self, ctx, *, resposta_usuario):
        if not hasattr(self, 'current_charada'):
            await ctx.reply("‚ùå Nenhuma charada ativa no momento. Use `!charada` primeiro.", mention_author=False)
            return
            
        correta = self.current_charada['resposta'].lower()
        if resposta_usuario.lower().strip() == correta:
            embed = discord.Embed(title="‚úÖ Parab√©ns!", description="Resposta correta!", color=discord.Color.green())
            embed.add_field(name="Resposta", value=self.current_charada['resposta'].title())
            await ctx.reply(embed=embed, mention_author=False)
            self.update_user_stats(ctx.author.id, "quiz_wins")
            del self.current_charada
        else:
            await ctx.reply("‚ùå Resposta incorreta. Tente novamente!", mention_author=False)

    @commands.command(name='quiz')
    async def quiz(self, ctx):
        if ctx.channel.id in self.trivia_sessions:
            await ctx.reply("‚ùå J√° existe um quiz ativo neste canal.", mention_author=False)
            return
            
        pergunta = random.choice(self.quiz_data)
        self.trivia_sessions[ctx.channel.id] = {
            "pergunta": pergunta,
            "participants": {},
            "start_time": datetime.now()
        }
        
        embed = discord.Embed(title="üß† Quiz Time!", description=pergunta["pergunta"], color=discord.Color.purple())
        
        opcoes_text = ""
        for i, opcao in enumerate(pergunta["opcoes"]):
            opcoes_text += f"{chr(65+i)}) {opcao}\n"
        
        embed.add_field(name="Op√ß√µes:", value=opcoes_text, inline=False)
        embed.set_footer(text="Responda com A, B, C ou D. Voc√™ tem 30 segundos!")
        
        await ctx.reply(embed=embed, mention_author=False)
        
        # Timer para o quiz
        await asyncio.sleep(30)
        await self.end_quiz(ctx.channel)

    async def end_quiz(self, channel):
        if channel.id not in self.trivia_sessions:
            return
            
        session = self.trivia_sessions[channel.id]
        pergunta = session["pergunta"]
        resposta_correta = chr(65 + pergunta["resposta"])
        
        winners = [user_id for user_id, answer in session["participants"].items() 
                  if answer.upper() == resposta_correta]
        
        embed = discord.Embed(title="‚è∞ Quiz Finalizado!", color=discord.Color.gold())
        embed.add_field(name="Resposta Correta", value=f"{resposta_correta}) {pergunta['opcoes'][pergunta['resposta']]}", inline=False)
        
        if winners:
            winner_mentions = [f"<@{user_id}>" for user_id in winners]
            embed.add_field(name="üèÜ Vencedores", value=", ".join(winner_mentions), inline=False)
            for winner_id in winners:
                self.update_user_stats(winner_id, "quiz_wins")
                self.update_user_stats(winner_id, "trivia_points")
        else:
            embed.add_field(name="üò¢ Resultado", value="Ningu√©m acertou desta vez!", inline=False)
        
        await channel.send(embed=embed)
        del self.trivia_sessions[channel.id]

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author.bot:
            return
            
        # Verificar respostas do quiz
        if message.channel.id in self.trivia_sessions:
            if message.content.upper() in ['A', 'B', 'C', 'D']:
                self.trivia_sessions[message.channel.id]["participants"][message.author.id] = message.content.upper()
                await message.add_reaction("‚úÖ")

    @commands.command(name='countdown')
    async def countdown(self, ctx, segundos: int):
        if segundos < 1 or segundos > 60:
            await ctx.reply("‚ùå O n√∫mero deve estar entre 1 e 60 segundos.", mention_author=False)
            return
            
        embed = discord.Embed(title="‚è≥ Countdown", description=f"Iniciando contagem de {segundos} segundos", color=discord.Color.blue())
        message = await ctx.reply(embed=embed, mention_author=False)
        
        for i in range(segundos, 0, -1):
            embed.description = f"‚è≥ **{i}** segundos restantes"
            if i <= 5:
                embed.color = discord.Color.red()
            elif i <= 10:
                embed.color = discord.Color.orange()
                
            await message.edit(embed=embed)
            await asyncio.sleep(1)
            
        embed.title = "‚è∞ Tempo Esgotado!"
        embed.description = "üö® **ACABOU O TEMPO!** üö®"
        embed.color = discord.Color.red()
        await message.edit(embed=embed)

    @commands.command(name='pergunta')
    async def pergunta(self, ctx, *, pergunta_usuario):
        respostas = [
            "Sim, definitivamente!",
            "N√£o, de jeito nenhum.",
            "Talvez, quem sabe?",
            "Com certeza absoluta!",
            "N√£o conte com isso.",
            "√â bem poss√≠vel.",
            "Definitivamente n√£o.",
            "As chances s√£o boas.",
            "Melhor n√£o te dizer agora...",
            "Concentre-se e pergunte novamente.",
            "Sem d√∫vidas!",
            "Minha resposta √© n√£o.",
            "Sim, mas com ressalvas.",
            "√â incerto."
        ]
        
        resposta = random.choice(respostas)
        
        embed = discord.Embed(title="üé± Bola 8 M√°gica", color=discord.Color.dark_blue())
        embed.add_field(name="‚ùì Sua Pergunta:", value=pergunta_usuario, inline=False)
        embed.add_field(name="üí¨ Minha Resposta:", value=f"**{resposta}**", inline=False)
        
        await ctx.reply(embed=embed, mention_author=False)
        self.update_user_stats(ctx.author.id, "games_played")

    @commands.command(name='meme')
    async def meme(self, ctx):
        memes = [
            "Quando o c√≥digo funciona na primeira tentativa... √â bug ou milagre?",
            "Programador: aquela pessoa que resolve problemas que voc√™ n√£o sabia que tinha.",
            "Debugging: a arte de remover bugs... e adicionar outros.",
            "Se funcionou uma vez, funcionar√° sempre... ou n√£o.",
            "Coment√°rios no c√≥digo: 'Isso aqui eu entendo depois'... 2 anos depois...",
            "Stack Overflow: salvando vidas desde 2008.",
            "Ctrl+C, Ctrl+V: as teclas mais usadas por programadores.",
            "Quando o PM pede 's√≥ uma mudancinha r√°pida'... RIP weekend.",
            "Git commit -m 'fix bug'... cria 3 bugs novos.",
            "Caf√©: o combust√≠vel oficial dos programadores."
        ]
        
        meme_text = random.choice(memes)
        embed = discord.Embed(title="üòÇ Meme do Dia", description=meme_text, color=discord.Color.green())
        await ctx.reply(embed=embed, mention_author=False)

    @commands.command(name='stats')
    async def stats(self, ctx, member: discord.Member = None):
        member = member or ctx.author
        user_id = str(member.id)
        
        if user_id not in self.user_stats:
            await ctx.reply(f"‚ùå {member.display_name} ainda n√£o jogou nenhum jogo.", mention_author=False)
            return
            
        stats = self.user_stats[user_id]
        
        embed = discord.Embed(title=f"üìä Estat√≠sticas de {member.display_name}", color=discord.Color.blue())
        embed.add_field(name="üéÆ Jogos Jogados", value=stats.get("games_played", 0), inline=True)
        embed.add_field(name="üèÜ Quiz Vencidos", value=stats.get("quiz_wins", 0), inline=True)
        embed.add_field(name="‚≠ê Pontos Trivia", value=stats.get("trivia_points", 0), inline=True)
        
        win_rate = 0
        if stats.get("games_played", 0) > 0:
            win_rate = (stats.get("quiz_wins", 0) / stats.get("games_played", 0)) * 100
            
        embed.add_field(name="üìà Taxa de Vit√≥ria", value=f"{win_rate:.1f}%", inline=True)
        embed.set_thumbnail(url=member.avatar.url if member.avatar else member.default_avatar.url)
        
        await ctx.reply(embed=embed, mention_author=False)

    @commands.command(name='ranking')
    async def ranking(self, ctx, categoria: str = "pontos"):
        if categoria.lower() not in ["pontos", "vitorias", "jogos"]:
            await ctx.reply("‚ùå Categoria inv√°lida. Use: `pontos`, `vitorias` ou `jogos`", mention_author=False)
            return
            
        if categoria.lower() == "pontos":
            sorted_users = sorted(self.user_stats.items(), key=lambda x: x[1].get("trivia_points", 0), reverse=True)
            title = "üèÜ Ranking - Pontos Trivia"
            stat_key = "trivia_points"
        elif categoria.lower() == "vitorias":
            sorted_users = sorted(self.user_stats.items(), key=lambda x: x[1].get("quiz_wins", 0), reverse=True)
            title = "ü•á Ranking - Vit√≥rias em Quiz"
            stat_key = "quiz_wins"
        else:
            sorted_users = sorted(self.user_stats.items(), key=lambda x: x[1].get("games_played", 0), reverse=True)
            title = "üéÆ Ranking - Jogos Jogados"
            stat_key = "games_played"
        
        embed = discord.Embed(title=title, color=discord.Color.gold())
        
        for i, (user_id, stats) in enumerate(sorted_users[:10]):
            try:
                user = self.bot.get_user(int(user_id))
                if user:
                    medal = "ü•á" if i == 0 else "ü•à" if i == 1 else "ü•â" if i == 2 else f"{i+1}¬∫"
                    embed.add_field(
                        name=f"{medal} {user.display_name}",
                        value=f"{stats.get(stat_key, 0)} {categoria}",
                        inline=False
                    )
            except:
                continue
                
        if not embed.fields:
            embed.description = "Nenhum dado encontrado ainda."
            
        await ctx.reply(embed=embed, mention_author=False)

    @commands.command(name='rps')
    async def rock_paper_scissors(self, ctx, escolha: str):
        escolha = escolha.lower()
        opcoes = {'pedra': 'üóø', 'papel': 'üìÑ', 'tesoura': '‚úÇÔ∏è'}
        
        if escolha not in opcoes:
            await ctx.reply("‚ùå Escolha: `pedra`, `papel` ou `tesoura`", mention_author=False)
            return
            
        bot_escolha = random.choice(list(opcoes.keys()))
        user_emoji = opcoes[escolha]
        bot_emoji = opcoes[bot_escolha]
        
        # Determinar vencedor
        if escolha == bot_escolha:
            resultado = "ü§ù Empate!"
            cor = discord.Color.orange()
        elif (escolha == 'pedra' and bot_escolha == 'tesoura') or \
             (escolha == 'papel' and bot_escolha == 'pedra') or \
             (escolha == 'tesoura' and bot_escolha == 'papel'):
            resultado = "üéâ Voc√™ ganhou!"
            cor = discord.Color.green()
            self.update_user_stats(ctx.author.id, "quiz_wins")
        else:
            resultado = "üò¢ Voc√™ perdeu!"
            cor = discord.Color.red()
            
        embed = discord.Embed(title="üéÆ Pedra, Papel, Tesoura", color=cor)
        embed.add_field(name="Sua escolha", value=f"{user_emoji} {escolha.title()}", inline=True)
        embed.add_field(name="Minha escolha", value=f"{bot_emoji} {bot_escolha.title()}", inline=True)
        embed.add_field(name="Resultado", value=resultado, inline=False)
        
        await ctx.reply(embed=embed, mention_author=False)
        self.update_user_stats(ctx.author.id, "games_played")

async def setup(bot):
    await bot.add_cog(Fun(bot))